package main

import (
	"bufio"
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"os/exec"
	"strings"
	"sync"

	"github.com/DeanThompson/ginpprof"
	"github.com/gin-gonic/gin"
)

var (
	// generated by command line `head /dev/urandom | tr -dc A-Za-z0-9 | head -c 13 ; echo ''` on Linux bash
	testAPIKey  = "yb2Q1ozScRfJJ"
	adminAPIKey = "z77BV0FABp2PU"
)

type Stream struct {
	Format       string
	Container    string
	VideoProfile string
	DownloadWith string
	Size         string `json:",omitempty"`
	RealURLs     []string
}

type CmdResponse struct {
	Site    string
	Title   string
	Artist  string `json:",omitempty"`
	Streams []*Stream
}

func getRealURLsByYouGet(u string, s *Stream, wg *sync.WaitGroup) {
	defer wg.Done()
	downloadURL := strings.Replace(s.DownloadWith, "[URL]", u, -1)
	c := strings.Split(downloadURL, " ")
	c[0] = "-u"
	cmd := exec.Command("you-get", c...)
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		log.Println("you-get stdout pipe failed", err)
		return
	}
	err = cmd.Start()
	if err != nil {
		log.Println("starting you-get failed", err)
		return
	}

	scanner := bufio.NewScanner(stdout)
	scanner.Split(bufio.ScanLines)
	start := false
	var rawURLs string
	for scanner.Scan() {
		line := scanner.Text()
		if start {
			rawURLs += line
			continue
		}
		if strings.HasPrefix(line, "Real URL:") {
			start = true
		}
	}
	err = cmd.Wait()
	if err != nil {
		log.Println("waiting for you-get exiting failed", err)
		return
	}
	rawURLs = strings.Replace(rawURLs, "'", "\"", -1)
	err = json.Unmarshal([]byte(rawURLs), &s.RealURLs)
	if err != nil {
		log.Println("unmarshalling json failed", err, rawURLs)
		return
	}
}

func parseByYouGet(u string, r chan *CmdResponse) {
	cmd := exec.Command("you-get", "-i", u)
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		log.Println("you-get stdout pipe failed", err)
		r <- nil
		return
	}
	err = cmd.Start()
	if err != nil {
		log.Println("starting you-get failed", err)
		r <- nil
		return
	}

	resp := &CmdResponse{}
	var stream *Stream
	scanner := bufio.NewScanner(stdout)
	scanner.Split(bufio.ScanLines)
	status := 0
	for scanner.Scan() {
		line := scanner.Text()
		switch status {
		case 0:
			if strings.HasPrefix(line, "site:") {
				pos := strings.IndexByte(line, byte(' '))
				for line[pos] == ' ' {
					pos++
				}
				resp.Site = line[pos:]
				status = 1
			}
		case 1:
			if strings.HasPrefix(line, "title:") {
				pos := strings.IndexByte(line, byte(' '))
				for line[pos] == ' ' {
					pos++
				}
				resp.Title = line[pos:]
				status = 2
			}
		case 2:
			if strings.HasPrefix(line, "streams:") {
				status = 3
			}
		case 3:
			if strings.Contains(line, "- format:") {
				pos := strings.IndexByte(line, byte(':')) + 1
				for line[pos] == ' ' {
					pos++
				}
				stream = &Stream{
					Format: line[pos:],
				}
				resp.Streams = append(resp.Streams, stream)
				status = 4
			}
		case 4:
			if strings.Contains(line, "container:") {
				pos := strings.IndexByte(line, byte(':')) + 1
				for line[pos] == ' ' {
					pos++
				}
				stream.Container = line[pos:]
				status = 5
			}
		case 5:
			if strings.Contains(line, "video-profile:") {
				pos := strings.IndexByte(line, byte(':')) + 1
				for line[pos] == ' ' {
					pos++
				}
				stream.VideoProfile = line[pos:]
				status = 6
			}
		case 6:
			if strings.Contains(line, "size:") {
				pos := strings.IndexByte(line, byte(':')) + 1
				for line[pos] == ' ' {
					pos++
				}
				stream.Size = line[pos:]
				status = 7
			}
		case 7:
			if strings.Contains(line, "# download-with:") {
				pos := strings.IndexByte(line, byte(':')) + 1
				for line[pos] == ' ' {
					pos++
				}
				stream.DownloadWith = line[pos:]
				status = 3
			}
		}
	}

	var wg sync.WaitGroup
	wg.Add(len(resp.Streams))
	for _, s := range resp.Streams {
		go getRealURLsByYouGet(u, s, &wg)
	}
	wg.Wait()
	err = cmd.Wait()
	if err != nil {
		log.Println("waiting for you-get exiting failed", err)
		r <- nil
		return
	}
	r <- resp
}

func parseByYKDL(u string, r chan *CmdResponse) {
	cmd := exec.Command("ykdl.py", "-i", u)
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		log.Println("ykdl stdout pipe failed", err)
		r <- nil
		return
	}
	err = cmd.Start()
	if err != nil {
		log.Println("starting ykdl failed", err)
		r <- nil
		return
	}

	resp := &CmdResponse{}
	var stream *Stream
	scanner := bufio.NewScanner(stdout)
	scanner.Split(bufio.ScanLines)
	status := 0
	for scanner.Scan() {
		line := scanner.Text()
		switch status {
		case 0:
			if strings.HasPrefix(line, "site:") {
				pos := strings.IndexByte(line, byte(' '))
				for line[pos] == ' ' {
					pos++
				}
				resp.Site = line[pos:]
				status = 1
			}
		case 1:
			if strings.HasPrefix(line, "title:") {
				pos := strings.IndexByte(line, byte(' '))
				for line[pos] == ' ' {
					pos++
				}
				resp.Title = line[pos:]
				status = 2
			}
		case 2:
			if strings.HasPrefix(line, "artist:") {
				pos := strings.IndexByte(line, byte(' '))
				for line[pos] == ' ' {
					pos++
				}
				resp.Artist = line[pos:]
				status = 3
			}
		case 3:
			if strings.HasPrefix(line, "streams:") {
				status = 4
			}
		case 4:
			if strings.Contains(line, "- format:") {
				pos := strings.IndexByte(line, byte(':')) + 1
				for line[pos] == ' ' {
					pos++
				}
				stream = &Stream{
					Format: line[pos:],
				}
				resp.Streams = append(resp.Streams, stream)
				status = 5
			}
		case 5:
			if strings.Contains(line, "container:") {
				pos := strings.IndexByte(line, byte(':')) + 1
				for line[pos] == ' ' {
					pos++
				}
				stream.Container = line[pos:]
				status = 6
			}
		case 6:
			if strings.Contains(line, "video-profile:") {
				pos := strings.IndexByte(line, byte(':')) + 1
				for line[pos] == ' ' {
					pos++
				}
				stream.VideoProfile = line[pos:]
				status = 7
			}
		case 7:
			if strings.Contains(line, "# download-with:") {
				pos := strings.IndexByte(line, byte(':')) + 1
				for line[pos] == ' ' {
					pos++
				}
				stream.DownloadWith = line[pos:]
				status = 8
			}
		case 8:
			if strings.HasPrefix(line, "Real urls:") {
				stream.RealURLs = []string{}
				status = 9
			}
		case 9:
			if strings.Contains(line, "- format:") {
				pos := strings.IndexByte(line, byte(':')) + 1
				for line[pos] == ' ' {
					pos++
				}
				stream = &Stream{
					Format: line[pos:],
				}
				resp.Streams = append(resp.Streams, stream)
				status = 5
				break
			}
			stream.RealURLs = append(stream.RealURLs, line)
		}
	}
	err = cmd.Wait()
	if err != nil {
		log.Println("waiting for ykdl exiting failed", err)
		r <- nil
		return
	}

	r <- resp
}

func checkInput(c *gin.Context) (u string, err error) {
	apiKey := c.PostForm("apikey")
	if apiKey == "" {
		c.JSON(http.StatusOK, gin.H{
			"Status": "error",
			"Result": "incorrect api key",
		})
		err = errors.New("incorrect api key")
		return
	}

	u = c.PostForm("url")
	if u == "" {
		c.JSON(http.StatusOK, gin.H{
			"Status": "error",
			"Result": "missing url",
		})
		err = errors.New("missing url")
		return
	}
	return
}

func handlePreferredParseRequest(c *gin.Context) {
	u, err := checkInput(c)
	if err != nil {
		return
	}

	fromYKDL := make(chan *CmdResponse)
	go parseByYKDL(u, fromYKDL)
	resultFromYKDL := <-fromYKDL

	c.JSON(http.StatusOK, gin.H{
		"Result":    "OK",
		"Perferred": resultFromYKDL,
	})
}

func handleBackupParseRequest(c *gin.Context) {
	u, err := checkInput(c)
	if err != nil {
		return
	}

	fromYouGet := make(chan *CmdResponse)
	go parseByYouGet(u, fromYouGet)
	resultFromYouGet := <-fromYouGet

	c.JSON(http.StatusOK, gin.H{
		"Result": "OK",
		"Backup": resultFromYouGet,
	})
}

func handleParseRequest(c *gin.Context) {
	u, err := checkInput(c)
	if err != nil {
		return
	}

	var resultFromYKDL, resultFromYouGet *CmdResponse
	fromYKDL := make(chan *CmdResponse)
	go parseByYKDL(u, fromYKDL)
	fromYouGet := make(chan *CmdResponse)
	go parseByYouGet(u, fromYouGet)
	for i := 0; i < 2; {
		select {
		case resultFromYKDL = <-fromYKDL:
			i++
		case resultFromYouGet = <-fromYouGet:
			i++
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"Result":    "OK",
		"Perferred": resultFromYKDL,
		"Backup":    resultFromYouGet,
	})
}

func main() {
	gin.SetMode(gin.ReleaseMode)
	r := gin.Default()

	// Ping test
	r.GET("/ping", func(c *gin.Context) {
		c.String(200, "pong")
	})

	v1 := r.Group("/v1")
	{
		v1.POST("/parse", handleParseRequest)
		v1.POST("/parse/all", handleParseRequest)
		v1.POST("/parse/preferred", handlePreferredParseRequest)
		v1.POST("/parse/backup", handleBackupParseRequest)
	}

	ginpprof.Wrapper(r)
	// Listen and Server in 127.0.0.1:8765
	r.Run("127.0.0.1:8765")
}
